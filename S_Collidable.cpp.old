#include "S_Collidable.hpp"


S_Collidable::S_Collidable() : collisionTree(5, 5, 0, 
	//quadtree dimensions 
	{ 0, 0, 4300, 1080 }, nullptr)
{
	Bitmask defaultCollisions; // 1
	defaultCollisions.SetBit((int)CollisionLayer::Default);   // 2 
	collisionLayers.insert(
		std::make_pair(CollisionLayer::Default, defaultCollisions)); // 3

	collisionLayers.insert(std::make_pair(CollisionLayer::Tile, Bitmask(0)));

	Bitmask playerCollisions;
	playerCollisions.SetBit((int)CollisionLayer::Default);
	playerCollisions.SetBit((int)CollisionLayer::Tile);
	collisionLayers.insert(std::make_pair(CollisionLayer::Player, playerCollisions));

	//set the bitmask for projectiles
	Bitmask projectileCollisions;
	// Projectiles will only collide with tiles for now.
	projectileCollisions.SetBit((int)CollisionLayer::Tile);
	collisionLayers.insert(std::make_pair(CollisionLayer::Projectile, projectileCollisions));

}

void S_Collidable::Add(std::vector<std::shared_ptr<Object>>& objects)
{
	for (auto o : objects)
	{
		auto collider = o->GetComponent<C_BoxCollider>();
		if (collider)
		{
			CollisionLayer layer = collider->GetLayer();

			auto itr = collidables.find(layer);

			if (itr != collidables.end())
			{
				collidables[layer].push_back(collider);
			}
			else
			{
				std::vector<std::shared_ptr<C_BoxCollider>> objs;
				objs.push_back(collider);

				collidables.insert(std::make_pair(layer, objs));
			}
		}
	}
}

void S_Collidable::ProcessRemovals()
{
	for (auto& layer : collidables)
	{
		auto itr = layer.second.begin();
		while (itr != layer.second.end())
		{
			if ((*itr)->owner->IsQueuedForRemoval())
			{
				itr = layer.second.erase(itr);
			}
			else
			{
				++itr;
			}
		}
	}
}



void S_Collidable::Update()
{
#ifdef _DEBUG
	collisionTree.DrawDebug();
#endif
	
	//ProcessCollidingObjects();
	collisionTree.Clear();
	
	for (auto maps = collidables.begin();
		maps != collidables.end(); ++maps)
	{
		for (auto collidable : maps->second)
		{
			collisionTree.Insert(collidable);
		}
	}

	Resolve();
}

void S_Collidable::ProcessCollidingObjects()
{
	auto itr = objectsColliding.begin();
	while (itr != objectsColliding.end())
	{
		auto pair = *itr;

		std::shared_ptr<C_BoxCollider> first = pair.first;
		std::shared_ptr<C_BoxCollider> second = pair.second;

		if (first->owner->IsQueuedForRemoval() || second->owner->IsQueuedForRemoval())
		{
			first->owner->OnCollisionExit(second);
			second->owner->OnCollisionExit(first);

			itr = objectsColliding.erase(itr);

		}
		else
		{
			Manifold m = first->Intersects(second);

			if (!m.colliding)
			{
				first->owner->OnCollisionExit(second);
				second->owner->OnCollisionExit(first);

				itr = objectsColliding.erase(itr);
			}
			else
			{
				first->owner->OnCollisionStay(second);
				second->owner->OnCollisionStay(first);

				++itr;
			}
		}
	}
}

void S_Collidable::Resolve()
{
	for (auto maps = collidables.begin(); maps != collidables.end(); ++maps) // 1
	{
		// If this layer collides with nothing then no need to 
		// perform any further checks.
		if (collisionLayers[maps->first].GetMask() == 0)
		{
			continue;
		}

		for (auto collidable : maps->second) // 1
		{
			// If this collidable is static then no need to check if 
			// it's colliding with other objects.
			if (collidable->owner->transform->isStatic())
			{
				continue;
			}

			//std::vector<std::shared_ptr<C_BoxCollider>> collisions
			//	= collisionTree.Search(collidable->GetCollidable()); // 2

			std::vector<std::shared_ptr<C_BoxCollider>> collisions = collisionTree.Search(collidable->GetCollidable());

			for (auto collision : collisions) // 3
			{
				// Make sure we do not resolve collisions between the same object.
				if (collidable->owner->instanceID->Get()
					== collision->owner->instanceID->Get())
				{
					continue;
				}

				bool layersCollide =
					collisionLayers[collidable->GetLayer()].GetBit(((int)collision->GetLayer()));

				if (layersCollide) // 3a
				{
					Manifold m = collidable->Intersects(collision); // 3b

					if (m.colliding)
					{
#ifdef _DEBUG
						Debug::DrawRect(collision->GetCollidable(), sf::Color::Red);
						Debug::DrawRect(collidable->GetCollidable(), sf::Color::Red);
#endif
						auto collisionPair = objectsColliding.emplace(std::make_pair(collidable, collision));


						if (collisionPair.second)
						{
							collidable->owner->OnCollisionEnter(collision);
							collision->owner->OnCollisionEnter(collidable);
						}


					}
				}
			}

		}
	}
}